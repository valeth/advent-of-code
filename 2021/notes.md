## Thoughts about each language

### Ruby

Already was familiar with it, so nothing notable here.

### Ada

Actually quite usable.
The syntax is a bit too verbose for my taste.
The only little annoyance I ran into was the way integers
are rendered when converted to strings.

### Perl

No. Just No.
The mandatory variable prefixing is annoying.
Lists are just a broken feature, and passing them to a
function will not lead to the expected result.
I heard that hashes are equally as broken, but I had no
use for them here.
This language just makes me appreciate Ruby more.

### Go

Module handling is a bit weird but works after some ceremony.
Didn't really like the way errors are handled.
The fact that elements are copied when iterating
made it a bit cumbersome to use.

### Nim

Might become my second favorite compiled language after Rust.
Reminded me a bit of Python with the significant whitespace.
It can infer types in let bindings, which helps make code less noisy.
Mutable variables being different from immutables is nice, love to see that.
Another plus is that identifiers and types are
in the correct order (`ident: Type` > `Type ident`).

### Inko

Was just a language that I found some time ago,
and wanted to try it with something.
Documentation is quite lacking, and compiler errors are not
that helpful.
The way that control flow is handled is a bit unconventional.
Feels like a weird mix between Rust and Ruby, but not quite.

### Swift

Couldn't figure out how creating modules works.
Was quite straightforward for the most part once I figured out
that the `Foundation` package is pretty much essential.

### C#

Requires everything to be wrapped in classes like Java, not great.
Very verbose due to lack of inferred types in many places.
Linq queries are kinda nice.

### C

Well, it's C, a barebones language where you pretty much have to
implement everything you need by yourself.
I don't know why but `atoi` threw me for a loop at first,
because it parsed parts of the input incorrectly for some reason.

### OCaml

Quite pleasant experience.
Everything that I needed was quickly found in documentation.
The syntax is quite similar to Haskell, so not many
issues there.
